<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>        MMORPG with Photon Unity Server
</title>
    <link rel="stylesheet" href="public/css/scholarly.css">
    <link rel="stylesheet" href="public/js/prismjs/themes/prism-coy.css">
    <script src="public/js/prismjs/prism.js" defer></script>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <style>
        p {
            text-align: justify;
        }
    </style>
</head>
<body prefix="schema: http://schema.org/ xsd: http://www.w3.org/2001/XMLSchema# sa: https://ns.science.ai/">
<header>
    <p class="title">        MMORPG with Photon Unity Server
        </p>
</header>
<article id="what" typeof="schema:ScholarlyArticle" resource="#">
    <h1> Developing a MMORPG using Photon Unity Server</h1>
    <section>
        <ol>            
            <li property="schema:contributor" typeof="sa:ContributorRole">
                <a property="schema:contributor" href="https://github.com/astonished12" typeof="schema:Person">
                    <span property="schema:givenName">Dan - Stefan</span>
                    <span property="schema:familyName">Cehan</span>
                </a>
            </li>
        </ol>
        <ol>
            <li id="scienceai">
                <a href="https://www.info.uaic.ro/bin/Main/" typeof="schema:Corporation">
                    <span property="schema:name">Faculty of Computer Science</span>
                </a>
            </li>
        </ol>
    </section>

    <section typeof="sa:Abstract" id="abstract">
        <h2>Abstract</h2>
        <p>
                This paper will explain how multiplayer can be implemented using Untiy as game engine and Photonâ€™s networking functionality.
                The main purposes of this is to offer info about implementing a dedicated server, connecting clients to it, spawning and synchronizing virtual players on the network.
        </p>
    </section>
   
    
    <section typeof="introduction" id="doc-introduction">
            <h2>Unity and Photon Server</h2>
            <p>
                    Unity is a cross-platform game engine developed by Unity Technologies, which is primarily used to develop both three-dimensional and two-dimensional video games and simulations for computers, consoles, and mobile devices. 
            </p>
            <p>
                    Photon is a on-premises real-time socket server and cross platform multiplayer game development framework that is extremely fast and very simple to use.
            </p>
    </section>

    
    <figure typeof="sa:Image">
        <img src="public/resources/photon_server_architecture.png">
        <figcaption>
            <center> Photon High Level Architecture  </center>
        </figcaption>
    </figure>

    <section id="protocols">
        <h3>Protocols of Photon Server</h3>
        <p>
            <li><strong>reliable UDP</strong> (based on eNET) and specially tuned for Client-2-Server architectures</li>
            <li>Binary Tcp</li>
            <li>Web Sockets</li>
            <li>Http</li>
        </p>

        <p>The transfer protocol is very lean and slim. Photon wraps up the networking layer of each client platform for you. Have your game clients communicate cross-platform and across protocols. Put your data in hashtables and just send it. Photon does the de-/serialization, you dont!</p>
    </section>

    <section id="started">
        <h3>Download server sdk and prepare structure </h3>
        <p>
        Photon is extremely easy to install and start. The SDK includes ready-to-use binaries which can be up and running within 5 minutes.
        The Photon Server SDKs are available on the official page and comes as self-extracting executable.
       </p>
        <p> The server package ca be extracted to any place - preferably an empty folder prepared beforehand. 
            The extraction creates several folders. The "deploy" folder contains the binaries. This is what you need at least to run Photon. The folders doc, lib and src-server (applications) are for development.
        </p>
       <h3>Starting Photon</h3>
       <p>In the "deploy" folder you will find a folder per application and some folders starting with "bin".
            Open one of these two:  
    <li><strong>bin_Win32</strong>: Windows Vista and up</li>
    <li><strong>bin_Win64</strong>: 64 bit Windows Vista and up</li>
    </p>
        <p>In either folder, you will find the actual Photon executable. You can start this with command-line arguments or you can use PhotonControl.
        Start PhotonControl.exe and confirm the admin rights for this application. They are needed for the option to setup Photon as a Service.  
    </p>    
</section>

<figure typeof="sa:Image">
    <img src="public/resources/photon_control.png">
    <figcaption>
        <center>Start application server as service </center>
    </figcaption>
</figure>

<section id="implementing">
    <h3>Build server application</h3>
    <p>
        Using Visual Studio, create a new class library project MyServer. After this
        is important to add references to <strong>ExitGamesLibs.dll, Photon.SocketServer.dll, PhotonHostRuntimeInterfaces.dll</strong>
and loggings dll's <strong>log4net.dll, ExitGame.Logging.Log4Net.dll </strong>.
    </p> 
    <p>
    Next step is to create an class that inherits from Photon.SocketServer.ApplicationBase. This class is the core luncher of the server and contains a reference to log4net object that will be used in logging.
    Every client request is handled by an special class inhterited from ClientPeer.
</p>

    
    <h4>Operation concept</h4>

    <p>The server project deal with game logic of every client, chat operations and game world.
        The game logic defines how a client can interact with the server. It implements operations, events, and anything that the server does by itself.
    </p>
    <p>
            An operation is Photon's equivalent to a remote procedure call. Photon clients use operation calls for anything they want to get done.
            Operations and all of their parameters are defined in the <strong>PhotonMMORPG.Common</strong> project. Clients can call any operation by setting up a hashtable with keys and values fitting the operation's conventions. The client and server frameworks take care of serialization, transfer and deserialization.
    </p>

    <figure typeof="sa:Image">
        <img src="public/resources/operations_responses.png">
        <figcaption>
            <center>Operations and handlers</center>
        </figcaption>
    </figure>
        

    <h4>Event concept</h4>

    <p>
            Photon Events are messages for clients. Each event is typed by a byte code and carries game updates.
            Unlike operation results, a received event is most likely caused another client's operation call. This means: Events might arrive anytime. Lite sends events when someone joins or leaves a room.
    </p>
</section>
   
<section id="client-app">
            
    <h3>Build client application</h3>
    <p>
        Using the free license we can support from 1 to 100 concurent connections (players that are connected at the same time).   
        To establish a connection we must add <strong>Phton3Unity3D</strong> plugin as reference to our client project and then using the PhotonPeer we can connect to server address.
    </p>
    <p>
        The game is composed by scenes and every one will use the instance of PhotonPeer that was specify above to send the catched inputs. 
        Also it has the responsabilty of handling the server responses and perform transformations over the game state.    
    </p>
    <h4>Game State</h4>
    <p>
            The game state is a snapshot of the game at a particular instant of time. This
    includes the position of the PCs and the NPCs as well as the state of the
    mutable objects. Immutable objects are generally not part of the game state,
    and are typically installed as part of the game client software, and updated
    through software update mechanisms. The game state can be changed through
    the following interactions between game objects
    <li>position change</li>
    <li>player-object interaction</li>
    <li>player-player interaction</li>
    <p></p>
    <p>The game state for a MMORPG should be persistent so that the user experience
    is carried over seamlessly across dierent login sessions. At current point game state isn't persistent</p>
    </p>
    <h3>Game scene</h3>
    <p>
        The most popular online multiplayer games belong to a group of role-playing games
    (RPG). In general, the RPG involves a selection of fantasy characters that will delve into
    the game world and explore its content. The game character has a unique history and
    features based on the storyline of the game. Each character may belong to a particular
    race such as Elf, Orc, Undead or Human and plays a reserved role in the game world.
    <p>A combination of online multiplayer game and role-playing context results in a concept
    of a massive multiplayer online role-playing game (MMORPG). Every operation performed by client 
    will be procesed by server and synchronized to all participants.

    <h4>Character input and animator component</h4>
    </p>
        The player will control his own character and based on server decisions will modify the game state as we told.
        Every active character has an movement script and there in a loop will be waiting for movement inputs.
        This script allow the player to use the WASD and arrow keys, a controller pad or other device to move the player.   
    </p>

    
    <figure typeof="sa:Image">
        <img src="public/resources/move_animator.png">
        <figcaption>
            <center>Sync operations of main character</center>
        </figcaption>
    </figure>

    <p>
        The Animator component is used to assign animation to a GameObject in your scene in our case to character gameobject.
         The Animator component requires a reference to an Animator Controller which defines which animation clips to use, and controls when and how to blend and transition between them.
    </p>

    
    <figure typeof="sa:Image">
        <img src="public/resources/animator.png">
        <figcaption>
            <center>Sync operations of main character</center>
        </figcaption>
    </figure>
    
        
    
    </section>
    
</body>
</html>